name: CI/CD Pipeline

on:
  push:
    branches:
      - develop
    tags:
      - 'v*'
  release:
    types: [published]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  checks: write
  pull-requests: write

env:
  DOTNET_VERSION: '9.0.x'
  DOCKER_IMAGE_NAME: 'product-management-api'
  DOCKER_CONTAINER_NAME: 'product-management-api-container'

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.nuget/packages
            **/packages.lock.json
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Cache .NET build artifacts
        uses: actions/cache@v4
        with:
          path: |
            **/bin
            **/obj
          key: ${{ runner.os }}-dotnet-${{ hashFiles('**/*.csproj') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-dotnet-${{ hashFiles('**/*.csproj') }}-

      - name: Restore dependencies
        run: dotnet restore --verbosity minimal --nologo
        working-directory: ${{ github.workspace }}

      - name: Build solution
        run: dotnet build --configuration Release --no-restore --verbosity minimal --nologo
        working-directory: ${{ github.workspace }}

      - name: Run tests
        run: |
          dotnet test \
            --configuration Release \
            --no-build \
            --verbosity minimal \
            --nologo \
            --collect:"XPlat Code Coverage" \
            --results-directory:"${{ github.workspace }}/TestResults" \
            --settings:"${{ github.workspace }}/coverlet.runsettings" \
            --logger:"trx;LogFileName=test-results.trx"
        working-directory: ${{ github.workspace }}

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ${{ github.workspace }}/TestResults/**/*
          retention-days: 30

      - name: Publish test results
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: ${{ github.workspace }}/TestResults/**/*.trx

  build-docker-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to Docker Registry
        if: ${{ vars.DOCKER_REGISTRY_URL != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.DOCKER_REGISTRY_URL }}
          username: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.DOCKER_REGISTRY_URL != '' && format('{0}/{1}', vars.DOCKER_REGISTRY_URL, env.DOCKER_IMAGE_NAME) || env.DOCKER_IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: Build Docker image (without registry)
        if: ${{ vars.DOCKER_REGISTRY_URL == '' }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ github.workspace }}
          file: ${{ github.workspace }}/Dockerfile
          push: false
          tags: ${{ env.DOCKER_IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_CONFIGURATION=Release
          platforms: linux/amd64
          outputs: type=docker,dest=/tmp/docker-image.tar

      - name: Build and push Docker image (with registry)
        if: ${{ vars.DOCKER_REGISTRY_URL != '' }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ github.workspace }}
          file: ${{ github.workspace }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_CONFIGURATION=Release
          platforms: linux/amd64

      - name: Compress Docker image
        if: ${{ vars.DOCKER_REGISTRY_URL == '' }}
        run: |
          echo "Compressing Docker image..."
          if [ -f /tmp/docker-image.tar ]; then
            gzip -c /tmp/docker-image.tar > docker-image.tar.gz
            ls -lh docker-image.tar.gz
            echo "‚úÖ Image compressed successfully"
          else
            echo "‚ùå Docker image tar file not found at /tmp/docker-image.tar"
            exit 1
          fi

      - name: Upload Docker image artifact
        if: ${{ vars.DOCKER_REGISTRY_URL == '' }}
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar.gz
          retention-days: 1

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-docker-image
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: ${{ vars.PRODUCTION_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Download Docker image artifact
        if: ${{ vars.DOCKER_REGISTRY_URL == '' }}
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: .

      - name: Transfer Docker image to server
        if: ${{ vars.DOCKER_REGISTRY_URL == '' }}
        run: |
          echo "Verifying image file before transfer..."
          if [ ! -f docker-image.tar.gz ]; then
            echo "‚ùå Error: docker-image.tar.gz not found"
            exit 1
          fi
          file_size=$(stat -f%z docker-image.tar.gz 2>/dev/null || stat -c%s docker-image.tar.gz 2>/dev/null || echo "unknown")
          echo "Image file size: $file_size bytes"
          if [ "$file_size" = "0" ] || [ "$file_size" = "unknown" ]; then
            echo "‚ùå Error: Image file is empty or invalid"
            exit 1
          fi
          echo "Transferring image to server..."
          scp -P ${{ secrets.SERVER_PORT || '22' }} -o StrictHostKeyChecking=no \
            docker-image.tar.gz \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/docker-image.tar.gz
          echo "‚úÖ Image transferred successfully"

      - name: Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PORT: ${{ secrets.SERVER_PORT || '22' }}
          DOCKER_IMAGE_NAME: ${{ env.DOCKER_IMAGE_NAME }}
          DOCKER_CONTAINER_NAME: ${{ env.DOCKER_CONTAINER_NAME }}
          APP_PORT: ${{ secrets.APP_PORT }}
          REGISTRY_URL: ${{ vars.DOCKER_REGISTRY_URL }}
          MONGODB_CONNECTION_STRING: ${{ secrets.MONGODB_CONNECTION_STRING }}
          MONGODB_DATABASE_NAME: ${{ secrets.MONGODB_DATABASE_NAME }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
          SECURITY_PASSWORD_PEPPER: ${{ secrets.SECURITY_PASSWORD_PEPPER }}
        run: |
          ssh -p $SERVER_PORT -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            set -e
            
            echo 'üöÄ Starting deployment process...'
            
            IMAGE_NAME='$DOCKER_IMAGE_NAME'
            CONTAINER_NAME='$DOCKER_CONTAINER_NAME'
            APP_PORT='$APP_PORT'
            REGISTRY_URL='$REGISTRY_URL'
            
            if [ -n \"\$REGISTRY_URL\" ]; then
              FULL_IMAGE_NAME=\"\${REGISTRY_URL}/\${IMAGE_NAME}:latest\"
            else
              FULL_IMAGE_NAME=\"\${IMAGE_NAME}:latest\"
            fi
            
            if [ -n \"\$REGISTRY_URL\" ]; then
              echo 'üì• Pulling latest image from registry...'
              docker pull \"\$FULL_IMAGE_NAME\" || echo '‚ö†Ô∏è  Image pull failed, will use existing image'
            else
              echo 'üì• Loading image from transferred file...'
              if [ -f /tmp/docker-image.tar.gz ]; then
                file_size=\$(stat -f%z /tmp/docker-image.tar.gz 2>/dev/null || stat -c%s /tmp/docker-image.tar.gz 2>/dev/null || echo '0')
                echo \"   File size: \$file_size bytes\"
                if [ \"\$file_size\" -eq 0 ]; then
                  echo '‚ùå Error: Image file is empty'
                  exit 1
                fi
                echo '   Decompressing and loading image...'
                if gunzip -c /tmp/docker-image.tar.gz | docker load; then
                  rm -f /tmp/docker-image.tar.gz
                  echo '‚úÖ Image loaded successfully'
                  docker images | grep \"\$IMAGE_NAME\" || echo '‚ö†Ô∏è  Warning: Image not found in docker images list'
                else
                  echo '‚ùå Error: Failed to load Docker image'
                  echo '   Verifying file integrity...'
                  file /tmp/docker-image.tar.gz
                  exit 1
                fi
              else
                echo '‚ùå Error: No image file found at /tmp/docker-image.tar.gz'
                exit 1
              fi
            fi
            
            if [ \"\$(docker ps -aq -f name=\$CONTAINER_NAME)\" ]; then
              echo 'üõë Stopping existing container...'
              docker stop \$CONTAINER_NAME || true
              echo 'üóëÔ∏è  Removing existing container...'
              docker rm \$CONTAINER_NAME || true
            fi
            
            mkdir -p /var/log/\$CONTAINER_NAME
            
            echo 'üöÄ Starting new container...'
            echo '   Using port '\$APP_PORT' for both internal and external mapping'
            docker run -d \
              --name \$CONTAINER_NAME \
              --restart unless-stopped \
              -p \$APP_PORT:\$APP_PORT \
              -e ASPNETCORE_ENVIRONMENT=Production \
              -e ASPNETCORE_HTTP_PORTS=\$APP_PORT \
              -e MONGODB_CONNECTION_STRING='$MONGODB_CONNECTION_STRING' \
              -e MONGODB_DATABASE_NAME='$MONGODB_DATABASE_NAME' \
              -e JWT_SECRET_KEY='$JWT_SECRET_KEY' \
              -e JWT_ISSUER='$JWT_ISSUER' \
              -e JWT_AUDIENCE='$JWT_AUDIENCE' \
              -e SECURITY_PASSWORD_PEPPER='$SECURITY_PASSWORD_PEPPER' \
              -v /var/log/\$CONTAINER_NAME:/app/logs \
              --health-cmd='curl -f http://localhost:'\$APP_PORT'/health || exit 1' \
              --health-interval=5s \
              --health-timeout=3s \
              --health-start-period=10s \
              --health-retries=3 \
              \$FULL_IMAGE_NAME
            
            echo '‚è≥ Waiting for container to be healthy...'
            timeout=15
            elapsed=0
            while [ \$elapsed -lt \$timeout ]; do
              if docker inspect --format='{{.State.Health.Status}}' \$CONTAINER_NAME | grep -q 'healthy'; then
                echo '‚úÖ Container is healthy!'
                break
              fi
              sleep 2
              elapsed=\$((elapsed + 2))
              echo '   Waiting... ('\$elapsed'/'\$timeout' seconds)'
            done
            
            echo 'üìä Container status:'
            docker ps -a | grep \$CONTAINER_NAME
            
            echo 'üìã Recent logs:'
            docker logs --tail 20 \$CONTAINER_NAME
            
            echo '‚úÖ Deployment completed successfully!'
          "

      - name: Verify deployment
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PORT: ${{ secrets.SERVER_PORT || '22' }}
          APP_PORT: ${{ secrets.APP_PORT }}
        run: |
          sleep 3
          ssh -p ${{ secrets.SERVER_PORT || '22' }} -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "docker ps | grep ${{ env.DOCKER_CONTAINER_NAME }} && echo '‚úÖ Container is running on port $APP_PORT' || echo '‚ùå Container is not running'"
